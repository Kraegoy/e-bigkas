<!DOCTYPE html>
{% load static %}
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{% static 'styles/styles.css' %}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <title>Sign Language Detection</title>
</head>

<body>

    <div class="container">

        {% include 'nav.html' %}

        <div class="hangup_remind" id="hangup_remind">
            <div class="call-ended">Call ended</div>
            <button class="call_ended_okay" onclick="goHome()"> Okay
            </button>
        </div>
        <div class="hangup_overlay" id="hangup_overlay">
        </div>
        <audio id="localAudio" autoplay muted></audio>
        <audio id="remoteAudio" autoplay ></audio>
        <main class="main-content">

         
            <div class="chat-room">
                <div id="button-down" onclick="displaychat1()">
                   

                    <svg class="button-down" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                        <path fill="currentColor" d="M19.858 3.01H4.142C2.95 3.01 2 3.932 2 5.099v13.252c0 1.167.95 2.089 2.142 2.089l7.053-.001 2.923 2.873a.66.66 0 0 0 1.039-.004l2.92-2.868h.007l2.927 2.865a.66.66 0 0 0 1.04 0l2.924-2.868 7.058-.001C21.05 20.438 22 19.516 22 18.349V5.1c0-1.167-.95-2.09-2.142-2.09zM12 15.782c-1.124 0-2.04-.88-2.04-1.963 0-1.084.916-1.964 2.04-1.964s2.04.88 2.04 1.963c0 1.084-.916 1.964-2.04 1.964zm-5-6.798a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm10 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/>
                    </svg> 
                </div>
                
            </div>
            
                    <div id="video-streams">

                        <div class="video-container" id="user-container-1">
                            <div class="video-player" id="user-1">
                                <div class="username-wrapper"><span class="user-name">{{ request.user.username }}</span></div>

                                <video id="localVideo" style=" transform: scaleX(-1); height: 100%; width: 100%; position: relative; border-radius: 1.5em; object-fit: cover;" autoplay muted>
                                    <!-- Video element for open camera stream -->
                                </video> 

                                <canvas id="canvas" style="width: 100%; ; height: 100%; position: relative; border-radius: 1.5em;"></canvas>


                            </div>
                        </div>

                        <div class="video-container" id="user-container-2">
                            <div class="video-player" id="user-2">
                                <div class="username-wrapper"><span class="user-name">Other user</span></div> 
                                <video id="remoteVideo" style="height: 100%; width: 100%; position: relative; border-radius: 1.5em; object-fit: cover;" autoplay muted>
                                     <!-- Video element for receiving stream -->
                                </video>

                            </div> 

                        </div>


                    </div>

                    <div class='sent-actions'>
                        <div class='sent-header'>Sent-actions history for this call.</div>
                     
             
                    </div>
                
                    <section id="controls-wrapper">
                        <button id="toggleButton" class="runButton startButton">Start Recognition</button>

                        <div class="icon-wrapper">
                            <img class="control-icon" id="mic-btn" src="{% static '/images/microphone.svg' %}" />
                        </div>
            
                        <div class="icon-wrapper">
                            <img class="control-icon" id="camera-btn" src="{% static '/images/video.svg' %}" />
                        </div>
            
                        <div class="icon-wrapper">
                            <img class="control-icon" id="leave-btn" src="{% static '/images/leave.svg' %}" />
                        </div>
                    </section>  

            <div class="bottom-content">
                <div class="botbot">
                <div class="translation" id="scriptOutput">
                    <!-- Display translated text here -->
                    <p id="translatedText">e-Bigkas</p>
                </div>  
                <div class="sound-animation">
                    <!-- Add sound icon to the sound-bar -->
                    <div class="sound-bar">
                        <i class="fas fa-volume-up"></i> <!-- FontAwesome sound icon -->
                    </div>
                </div>
            </div>
            </div>
        </main>
        
    </div>

    <script src="{% static 'JS/index.js' %}"></script>
    
    <script src="{% static 'JS/libs/camera_utils.js' %}"></script>
    <script src="{% static 'JS/libs/control_utils.js' %}"></script>
    <script src="{% static 'JS/libs/drawing_utils.js' %}"></script>
    <script src="{% static 'JS/libs/holistic.js' %}"></script>



<script>
    const IsInvited = sessionStorage.getItem('invited');
    const loggedInUserId = sessionStorage.getItem('loggedInUserId');
    const invitingUserID = sessionStorage.getItem('invitingUserID');
    const invitedUserID = sessionStorage.getItem('invitedUserID');
    
    let user1;
    let user2;
    let conversationName = ''; 
    let sender;
    let receiver;
    let friend_userID;

    
    if (IsInvited == "true") {
        user1 = parseInt(invitingUserID);
        user2 = parseInt(loggedInUserId);
        sender = loggedInUserId;
        receiver = invitingUserID;
    } else {
        user1 = parseInt(loggedInUserId);
        user2 = parseInt(invitedUserID);
        sender = loggedInUserId;
        receiver = invitedUserID;
    }
    
    //console.log("sender: " + sender);
    //console.log("receiver: " + receiver);
    
    if (user1 > user2) {
        conversationName = `${user1} and ${user2}`;
    } else {
        conversationName = `${user2} and ${user1}`;
    }
    //console.log("ConversationName: " + conversationName);
    sessionStorage.setItem('ConversationName', conversationName);
    if(user1 == loggedInUserId){
        friend_userID = user2;
    }
    else{
        friend_userID = user1;
    }

    const buttondown = document.getElementById('button-down')
    const receiverUsername1 = sessionStorage.getItem('receiverUsername')
    buttondown.addEventListener("click", () => displaychat1(friend_userID, receiverUsername1));
    
    const sendButton = document.querySelector('#sendButton');
    sendButton.addEventListener('click', function(event) {
        event.preventDefault(); // Prevent the default form submission
    
        const messageInput = document.querySelector('#chat-input');
        const messageContent = messageInput.value.trim();
        if (messageContent === '') {
            // Handle empty message content
            return;
        }
    
        console.log("Sender ID:", sender);
        console.log("Receiver ID:", receiver);
    
        // Set the sender and receiver values to hidden input fields
        const senderInput = document.querySelector('#sender');
        const receiverInput = document.querySelector('#receiver');
        senderInput.value = sender;
        receiverInput.value = receiver;

            // Construct a form data object
        const formData = new FormData();
        formData.append('content', messageContent);
        formData.append('conversationName', conversationName); // Append the conversation name string
        formData.append('sender', sender);
        formData.append('receiver', receiver);
    
        const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;
        fetch('/send_message/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': csrftoken
                },
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                // Clear the message input field after sending the message
                messageInput.value = '';
            })
            .catch(error => {
                console.error('Error sending message:', error);
            });
    });

            document.addEventListener('DOMContentLoaded', async (event) => {
                otherUserId = (loggedInUserId == user1) ? user2 : user1;

                // Fetch the username of the other user
                const otherUserUsername = await fetchUsername(otherUserId);

                // Update the DOM with the usernames
                document.querySelector('#user-container-2 .user-name').textContent = otherUserUsername;
                const receiverUsername = sessionStorage.setItem('receiverUsername', otherUserUsername);
            });

            // Function to fetch username from the server
    async function fetchUsername(userId) {
        try {
            const response = await fetch(`/api/get-username/${userId}/`);
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            const data = await response.json();
            return data.username;
        } catch (error) {
            console.error('There was a problem with the fetch operation:', error);
            return 'Unknown User';
        }
    }   
    const messageBox = document.querySelector('.messages-container');
    let kk = false; 
    
    function displaychat() {

        
        kk = !kk; // Toggle the variable
        messageBox.style.display = kk ? 'block' : 'none'; // Toggle the display style
        
        // Toggle the rotation class for the arrow
        document.querySelector('.button-down').classList.toggle('rotated');

            scrollToBottom();
    }
    
    // Function to scroll to the bottom of the chat window
    function scrollToBottom() {
        const messagesContainer = document.querySelector('.messages');
        if (messagesContainer) {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
    }
    
</script>

<script>   

    // Get the current URL path
    const path = window.location.pathname;
    const parts = path.split('/');
    const roomID = parts[parts.length - 2]; 


    function handleKeyDown(event) {
        // Check if the Enter key is pressed
        if (event.keyCode === 13 && !event.shiftKey) {
            event.preventDefault(); // Prevent the default Enter key behavior (line break)
            sendMessage(); // Call the sendMessage function
        }
    }


    // Function to handle messages loaded event
    function handleMessagesLoaded(data) {
        //console.log("Received messages_loaded event from server. Data:", data);
        
        const messagesContainer = document.querySelector('.messages');
        const loggedInUserId = sessionStorage.getItem('loggedInUserId');
        
        messagesContainer.innerHTML = '';
        
        data.messages.forEach(message => {
            handleIncomingMessage(message);
        });
        scrollToBottom();

    }

    // Function to handle incoming messages
    function handleIncomingMessage(message) {
        console.log("loadedede")

        const messagesContainer = document.querySelector('.messages');
        const loggedInUserId = sessionStorage.getItem('loggedInUserId');

        const sender = message.sender_id == loggedInUserId ? 'your-messages' : 'friends-messages';

        const messageDiv = document.createElement('div');
        messageDiv.classList.add(sender);
        
        const messageContent = document.createElement('div');
        messageContent.textContent = message.content;
        messageContent.classList.add('indiv-messages');

        messageDiv.appendChild(messageContent);
        const timeSent = document.createElement('div');
        const messageDate = new Date(message.timestamp);
        const currentDate = new Date();

        if (messageDate.toDateString() === currentDate.toDateString()) {
            // Display time if message was sent today
            timeSent.textContent = messageDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
        } else {
            // Display date and time if message was sent on a different day
            const options = { month: 'short', day: 'numeric' };
            const formattedDate = messageDate.toLocaleDateString('en-US', options);
            timeSent.textContent = `${formattedDate}, ${messageDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })}`;
        }
        // Add appropriate CSS class based on sender
        timeSent.classList.add(message.sender_id == loggedInUserId ? 'your-time-sent' : 'friends-time-sent');
        messageDiv.appendChild(timeSent);
            
        messagesContainer.appendChild(messageDiv);
    }


    function sendMessage() {
        const chatInput = document.getElementById('chat-input');
        const messageContent = chatInput.value;
        const senderId = sessionStorage.getItem('loggedInUserId');
        const conversationName = sessionStorage.getItem('ConversationName');
        
        // Check if the user is the inviting or invited user based on session storage
        const isInvited = sessionStorage.getItem('invited') === 'true';
        const receiverId = isInvited ? sessionStorage.getItem('invitedUserID') : sessionStorage.getItem('invitingUserID');

        if (messageContent.trim() !== '' && receiverId) { 
            const message = {
                sender_id: senderId,
                receiver_id: receiverId, 
                content: messageContent,
                timestamp: new Date().toISOString(),
                conversationName: conversationName
            };
            
            console.log("Sending message:", message);
            socket.send(JSON.stringify({ type: 'message', message: message }));
            
            chatInput.value = '';
            
            scrollToBottom();
        } else {
            console.log('Receiver ID is null or undefined');
        }
    }



</script>

<script src="https://code.responsivevoice.org/responsivevoice.js?key=wJWpwJEV"></script>
</body>

<script>
    sessionStorage.setItem('isIncall', 'true');
    const isIncall = sessionStorage.getItem('isIncall');
    
    sessionStorage.setItem('roomID', roomID);
    const video = document.getElementById('video1');
    const receivedImgElement1 = document.getElementById('video2');

    
    //-------------------------------------------------Detection----------------------------------------------------------
    
    var toggleButton = document.getElementById('toggleButton');
    var speakButton = document.getElementById('speakButton');

    


    
    const leftNav = document.querySelector('.nav-container');
    const bottomContent = document.querySelector('.bottom-content');
    const videoContainer = document.querySelector('.video-container');
    const videStreams = document.querySelector('#video-streams');
    const controlsWrapper = document.querySelector('#controls-wrapper');
    const cameraBtn = document.getElementById('camera-btn');

    function speakText2(textToSpeak) {
        responsiveVoice.speak(textToSpeak, "UK English Male");
    }

    function typeText(element, text, index = 0) {
        if (index < text.length) {
            element.textContent += text.charAt(index);
            index++;
            setTimeout(() => typeText(element, text, index), 100); 
        }
    }



    
    function speakText(textToSpeak) {
        var synth = window.speechSynthesis;
        var utterance = new SpeechSynthesisUtterance(textToSpeak);
    
    
        // Set the voice directly without relying on onvoiceschanged event
        var voices = synth.getVoices();
        var femaleVoiceFound = false;
    
        // Look for a female voice in the available voices
        for (var i = 0; i < voices.length; i++) {
            // Check if the voice name contains a common female voice identifier
            if (voices[i].name.includes('Female') || voices[i].name.includes('Emily') || voices[i].name.includes('Zira')) {
                utterance.voice = voices[i];
                femaleVoiceFound = true;
                break;
            }
        }
    
        // Speak the utterance
        synth.speak(utterance);
    }

  
    
    document.addEventListener('DOMContentLoaded', function () {
        const addFriendForms = document.querySelectorAll('.add-friend-form');
        addFriendForms.forEach(form => {
            form.addEventListener('submit', function (event) {
                event.preventDefault();
                const formData = new FormData(form);
                const friendId = formData.get('friend_id');
                fetch(form.action, {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'X-CSRFToken': '{{ csrf_token }}'
                    }
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Reload the page
                        location.reload();
                    } else {
                        // Handle error
                        console.error(data.error);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                });
            });
        });
    });


    function reset_unread_count(conversation_name) {
        fetch(`/reset_unread_count/${encodeURIComponent(conversation_name)}/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken') // Ensure this function is correctly implemented
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log('Unread count reset successfully');
                // Optionally refresh the messages or UI
            }
        })
        .catch(error => console.error('Error:', error));
    }


    function goHome(){
        const roomID1 = sessionStorage.getItem('roomID');
        sessionStorage.removeItem('roomID');
        sessionStorage.removeItem('invitingUserID');
        sessionStorage.removeItem('invitedUserID');
        sessionStorage.removeItem('invited');
        sessionStorage.removeItem('ConversationName');

        fetch('/')
        .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        // Redirect to the home page
        window.location.href = '/';
        })
        .catch(error => {
        console.error('There was a problem with the fetch operation:', error);
        });      
    }

    document.getElementById('leave-btn').addEventListener('click', function() {
        // Retrieve room ID, username, and user ID from session storage
        const roomID = sessionStorage.getItem('roomID');
    
        fetch(`/update_call_duration/${roomID}/`, {
            method: 'POST', // Use POST as your backend expects it
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken') // Ensure you have a function to get the CSRF token
            },
            body: JSON.stringify({
                room_id: roomID // The backend expects this in the body
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Handle success (e.g., update the UI, notify the user)
                console.log('Call duration updated successfully.');
            } else {
                // Handle failure (e.g., display an error message)
                console.error('Failed to update call duration:', data);
            }
        })
        .catch(error => {
            console.error('Error:', error);
        });
    
        // Remove room ID, username, and user ID from session storage
        sessionStorage.removeItem('roomID');
        sessionStorage.removeItem('invitingUserID');
        sessionStorage.removeItem('invitedUserID');
        sessionStorage.removeItem('invited');
        sessionStorage.removeItem('ConversationName');
        
        let receiver_id;
        if (loggedInUserId == invitedUserID) {
            receiver_id = invitingUserID;
        } else {
            receiver_id = invitedUserID;
        }
    
        socket.send(JSON.stringify({
            type: 'hang_up',
            receiver_id: receiver_id,
        }));
        
        // JavaScript code to redirect the user to the home page
            fetch('/')
            .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            // Redirect to the home page
            window.location.href = '/';
            })
            .catch(error => {
            console.error('There was a problem with the fetch operation:', error);
            });

    });
    


    function loadFriendsConversations() {
        fetch("/friends_conversations/")
          .then((response) => response.json())
          .then((data) => {
            if (data.success) {
              const messageDropdown = document.getElementById("message-dropdown");
    
              // Clear existing content except the 'chats-text' div
              const existingChatsText = messageDropdown.querySelector(".chats-text");
              messageDropdown.innerHTML = "";
              messageDropdown.appendChild(existingChatsText);
    
              // Sort friends based on the timestamp of their last message (latest first)
              data.friends.sort((a, b) => {
                if (a.last_message && b.last_message) {
                  return (
                    new Date(b.last_message.timestamp) -
                    new Date(a.last_message.timestamp)
                  );
                } else if (a.last_message && !b.last_message) {
                  return -1; // A has a message, prioritize A
                } else if (!a.last_message && b.last_message) {
                  return 1; // B has a message, prioritize B
                } else {
                  return 0; // Both have no messages (shouldn't happen if filtering in backend)
                }
              });
    
              data.friends.forEach((friend) => {
                if (!friend.last_message) {
                  return; // Skip this friend if there's no last message
                }
    
                const friendMessage = document.createElement("div");
                friendMessage.classList.add("dropdown-messages");
    
                const profileImg = document.createElement("img");
                profileImg.src = friend.profile_picture;
                profileImg.alt = "Profile Picture";
                profileImg.classList.add("sender-profile");
    
                // Check if friend is online and add status indicator
                if (friend.status == "online") {
                  profileImg.style.position = "relative"; // Ensure profileImg has relative positioning for absolute positioning of status indicator
                  const statusIndicator = document.createElement("div");
                  statusIndicator.classList.add("status-indicator");
                  friendMessage.appendChild(statusIndicator);
                }
    
                const messageDetails = document.createElement("div");
                messageDetails.classList.add("message-details");
    
                const sender = document.createElement("div");
                sender.classList.add("message-sender");
                sender.textContent = friend.username;
    
                const unread_count = document.createElement("div");
                unread_count.classList.add("unread-count");
                unread_count.textContent = friend.unread_count;
    
                if (friend.unread_count > 0) {
                  unread_count.style.display = "block";
                } else {
                  unread_count.style.display = "none";
                }
    
                const content = document.createElement("span");
                content.classList.add("message-content");
    
                // Check if the logged-in user is the sender
                if (friend.last_message.sender == ako) {
                  content.textContent = `You: ${truncateText(
                    friend.last_message.content,
                    9
                  )}`;
                } else {
                  content.textContent = truncateText(
                    friend.last_message.content,
                    11
                  );
                }
    
                const loggedInUserID_for_displaychat1 =
                  sessionStorage.getItem("loggedInUserId");
                if (loggedInUserID_for_displaychat1 > friend.id) {
                  conversation_name = `${loggedInUserID_for_displaychat1} and ${friend.id}`;
                } else {
                  conversation_name = `${friend.id} and ${loggedInUserID_for_displaychat1}`;
                }
    
                friendMessage.addEventListener("click", function () {
                  displaychat1(friend.id, friend.username);
                  showMessageDropdown();
                  reset_unread_count(conversation_name);
                });
    
                const timestamp = document.createElement("span");
                timestamp.classList.add("message-timestamp");
                timestamp.textContent = formatDate(friend.last_message.timestamp);
    
                messageDetails.appendChild(sender);
                messageDetails.appendChild(content);
                messageDetails.appendChild(timestamp);
    
                friendMessage.appendChild(profileImg);
                friendMessage.appendChild(messageDetails);
                friendMessage.appendChild(unread_count);
    
                messageDropdown.appendChild(friendMessage);
              });
            }
          })
          .catch((error) => console.error("Error:", error));
      }

      const videoElement = document.getElementById('localVideo');
      const canvasElement = document.getElementById('canvas');
      const canvasCtx = canvasElement.getContext('2d');
      const mirroredCanvas = document.createElement('canvas'); // Create a mirrored canvas
      const mirroredCtx = mirroredCanvas.getContext('2d');
      
       
        function closeNav() {
          cameraBtn.style.backgroundColor = 'rgba(245, 222, 179, 0.886)';
          videoElement.src = '/static/images/ebigkas-logo.png'; 
          leftNav.classList.add('menu-opened');
          videoContainer.style.marginRight = '1.5em';
          videStreams.style.marginLeft = '74%';
          bottomContent.style.marginLeft = '-1%';
          controlsWrapper.style.marginLeft = '33%';
      }
  
      function openNav() {
          leftNav.classList.remove('menu-opened');
          videoContainer.style.marginRight = '2px';
          videStreams.style.marginLeft = '78.5%';
          bottomContent.style.marginLeft = '30px';
          controlsWrapper.style.marginLeft = '37%';
          cameraBtn.style.backgroundColor = 'rgb(255, 80, 80, 1)';
      }
        

      const micBtn = document.getElementById('mic-btn');
      let isMicOpen = false;
      let localStream;
      let peerConnection;
      
     

</script>





<script type="module">
    const IsInvited = sessionStorage.getItem('invited');
    const loggedInUserId = sessionStorage.getItem('loggedInUserId');
    const invitingUserID = sessionStorage.getItem('invitingUserID');
    const invitedUserID = sessionStorage.getItem('invitedUserID');

    const recognitionButton = document.getElementById('toggleButton')
    const cameraBtn = document.getElementById('camera-btn');
    const leftNav = document.querySelector('.nav-container');
    const bottomContent = document.querySelector('.bottom-content');
    const videoContainer = document.querySelector('.video-container');
    const videStreams = document.querySelector('#video-streams');
    const controlsWrapper = document.querySelector('#controls-wrapper');
    const canvasElement = document.getElementById('canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const mirroredCanvas = document.createElement('canvas'); // Create a mirrored canvas
    const mirroredCtx = mirroredCanvas.getContext('2d');
    const localVideo = document.getElementById('localVideo');

    const videoElement = document.getElementById('localVideo');

    let isRecognizing = false;

    let isCameraOpen = false;

    function closeNav() {
        videoElement.src = '/static/images/ebigkas-logo.png'; // Adjust if using Django static files
        leftNav.classList.add('menu-opened');
        videoContainer.style.marginRight = '1.5em';
        videStreams.style.marginLeft = '74%';
        bottomContent.style.marginLeft = '-1%';
        controlsWrapper.style.marginLeft = '33%';
    }

    function openNav() {
        leftNav.classList.remove('menu-opened');
        videoContainer.style.marginRight = '2px';
        videStreams.style.marginLeft = '78.5%';
        bottomContent.style.marginLeft = '30px';
        controlsWrapper.style.marginLeft = '37%';
    }

    function mirrorVideoFrame(videoElement) {
        // Set dimensions for the mirrored canvas
        mirroredCanvas.width = videoElement.videoWidth;
        mirroredCanvas.height = videoElement.videoHeight;

        // Apply mirroring effect
        mirroredCtx.translate(mirroredCanvas.width, 0); // Move origin to the far right
        mirroredCtx.scale(-1, 1); // Flip horizontally

        // Draw the video frame onto the mirrored canvas
        mirroredCtx.drawImage(videoElement, 0, 0, mirroredCanvas.width, mirroredCanvas.height);
        
        return mirroredCanvas;
    }

         // WebRTC configuration
         const configuration = { 
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] // Public STUN server
        };
        
        function createPeerConnection() {
          peerConnection = new RTCPeerConnection(configuration);
      
          peerConnection.onicecandidate = function(event) {
              if (event.candidate) {
                //  console.log('ICE Candidate:', event.candidate);
                  socket.send(JSON.stringify({
                      type: 'ice_candidate',
                      candidate: event.candidate,
                      sender_id: loggedInUserId,
                      room_id: roomID
                  }));
              }
          };
      
          peerConnection.ontrack = function(event) {
              console.log('Remote stream added:', event.streams[0]);
              const remoteAudio = document.getElementById('remoteAudio');
              const remoteVideo = document.getElementById('remoteVideo'); 
          
              if (remoteAudio && event.track.kind === 'audio') {
                  remoteAudio.srcObject = event.streams[0]; // Assign audio stream
              }
              
              if (remoteVideo && event.track.kind === 'video') {
                  remoteVideo.srcObject = event.streams[0]; // Assign video stream
              }
          };
          
      }
      
      
      async function startRecordingAudio() {
          try {
              localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
              document.getElementById('localAudio').srcObject = localStream;
      
              if (!peerConnection) createPeerConnection();
      
              localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
      
              const offer = await peerConnection.createOffer();
              await peerConnection.setLocalDescription(offer);
              socket.send(JSON.stringify({
                  type: 'offer',
                  sdp: offer.sdp,
                  sender_id: loggedInUserId,
                  room_id: roomID
              }));
          } catch (error) {
              console.error('Error accessing audio stream:', error);
          }
      }
      
        // Stop capturing and sending audio
        function stopRecordingAudio() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
        }
    
        
        // Toggle microphone state
        micBtn.addEventListener('click', async function onClick() {
          if (isMicOpen) {
              micBtn.style.backgroundColor = 'rgb(255, 80, 80, 1)'; // Red when muted
              stopRecordingAudio();
          } else {
              micBtn.style.backgroundColor = 'rgba(245, 222, 179, 0.886)'; // Beige when unmuted
              await startRecordingAudio();
          }
          isMicOpen = !isMicOpen;
      });
      
      
    
      const maxSequenceLength = 23; // Maintain this
      let sequence = [];
      let sequences_holder = [];
      
      function onResults(results) {
          // Save the current canvas state
          canvasCtx.save();
          // Clear the canvas efficiently
          canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      
          // Draw the image from MediaPipe results onto the canvas
          canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
      
          // Only draw connectors and landmarks if isRecognizing is true
          if (isRecognizing) {
              drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, { color: '#00FF00', lineWidth: 0.1 });
              drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_TESSELATION, { color: '#C0C0C070', lineWidth: 0.1 });
              drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, { color: '#CC0000', lineWidth: 0.5 });
              drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, { color: '#00CC00', lineWidth: 0.5 });
      
              drawLandmarks(canvasCtx, results.poseLandmarks, { color: 'rgba(0,0,0,0)', lineWidth: 0 });
              drawLandmarks(canvasCtx, results.faceLandmarks, { color: 'rgba(0,0,0,0)', lineWidth: 0 });
              drawLandmarks(canvasCtx, results.leftHandLandmarks, { color: 'rgba(0,0,0,0)', lineWidth: 0 });
              drawLandmarks(canvasCtx, results.rightHandLandmarks, { color: 'rgba(0,0,0,0)', lineWidth: 0 });
          }
      
          // Restore the canvas state
          canvasCtx.restore();
      
          // Extract keypoints and manage sequence
          const keypoints = extractKeypoints(results);
          sequence.push(keypoints);
      
          // Check if we have reached the maximum sequence length
          if (sequence.length === maxSequenceLength) {
              // Store the complete sequence into sequences_holder
              sequences_holder.push([...sequence]); // Push a copy of sequence
              sequence = []; // Reset the sequence for new input
          }
      }
      
    
    
    function extractKeypoints(results) {
        const pose = results.poseLandmarks ? 
            results.poseLandmarks.map(landmark => [landmark.x, landmark.y, landmark.z, landmark.visibility]).flat() :
            new Array(33 * 4).fill(0);
            
        // Use only the first 468 face keypoints (slice before flattening)
        const face = results.faceLandmarks ? 
            results.faceLandmarks.slice(0, 468).map(landmark => [landmark.x, landmark.y, landmark.z]).flat() :
            new Array(468 * 3).fill(0);  // Ensuring 468 keypoints are taken
    
        const leftHand = results.leftHandLandmarks ? 
            results.leftHandLandmarks.map(landmark => [landmark.x, landmark.y, landmark.z]).flat() :
            new Array(21 * 3).fill(0);
    
        const rightHand = results.rightHandLandmarks ? 
            results.rightHandLandmarks.map(landmark => [landmark.x, landmark.y, landmark.z]).flat() :
            new Array(21 * 3).fill(0);
    
        return [].concat(pose, face, leftHand, rightHand);
    }
    
    const holistic = new Holistic({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`
    });

    holistic.setOptions({
        modelComplexity: 1,
        smoothLandmarks: false,
        enableSegmentation: false,
        smoothSegmentation: false,
        refineFaceLandmarks: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
    });

    holistic.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            if (isRecognizing) {
                // Apply mirroring effect before sending to MediaPipe
                const mirroredCanvas = mirrorVideoFrame(videoElement);
                await holistic.send({ image: mirroredCanvas });
            }
        },
        width: 1280,
        height: 720,
    });



async function startRecordingCamera() {
  try {
      localStream = await navigator.mediaDevices.getUserMedia({ audio: false, video: true });
      document.getElementById('localVideo').srcObject = localStream;
      camera.stop();

      if (!peerConnection) createPeerConnection();

      localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      socket.send(JSON.stringify({
          type: 'offer',
          sdp: offer.sdp,
          sender_id: loggedInUserId,
          room_id: roomID
      }));

  } catch (error) {
      console.error('Error accessing video stream:', error);
  }
}

   // Stop capturing and sending audio
   function stopRecordingCamera() {
      if (localStream) {
          recognitionButton.innerHTML = "Start Recognition"; 
          localStream.getTracks().forEach(track => track.stop());
         
      }
      camera.stop();
     
  }


        cameraBtn.addEventListener('click', async function onClick() {
        if (isCameraOpen) {
                await camera.stop();
                stopRecordingCamera();
                isCameraOpen = false;
                cameraBtn.style.backgroundColor = 'rgb(255, 80, 80, 1)'; 
                openNav();
                setTimeout(function() {
                    socket.send(JSON.stringify({
                        type: 'video-frame',
                        frame: "{% static '/images/ebigkas1.png' %}",
                        sender_id: loggedInUserId,
                        room_id : roomID
                    }));            
                }, 100);
                
            } else {
                cameraBtn.style.backgroundColor = 'rgba(245, 222, 179, 0.886)'; 
                closeNav();
                await camera.stop();

                await startRecordingCamera();
                isCameraOpen = true;

            }
        });

        recognitionButton.addEventListener('click', async function() {
            if (isCameraOpen) {
                if (!isRecognizing) { // Start recognition
                    closeNav();
                    localVideo.style.display = 'none'; // Hide video for the sender
                    canvasElement.style.display = 'block'; // Show the canvas
                    await camera.start();
                    recognitionButton.innerHTML = "Stop Recognition"; 
                } else { // Stop recognition
                    openNav();
                    await camera.stop(); // Stop the camera
        
                    localVideo.style.display = 'block'; // Show the video again if needed
                    canvasElement.style.display = 'none'; 
        
                    // Clear the canvas
                    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height); 
                    
                    await startRecordingCamera(); 
                    socket.send(JSON.stringify({
                        type: 'predict_actions_taken',
                        data: sequences_holder,
                        sender_id: loggedInUserId,
                        room_id: roomID
                    }));
                    sequences_holder = []
                    
                    sequence = [];
                    recognitionButton.innerHTML = "Start Recognition"; 
                }
                isRecognizing = !isRecognizing;
            } else {
                alert("Camera not open.");
            }
        });
        
        
</script>


</html>